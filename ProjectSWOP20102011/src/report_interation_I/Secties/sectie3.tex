\section{Invloed van GRASP patterns}
\label{grasp}
\subsection{Bespreking van het systeem}
In onze implementatie proberen we in de meeste gevallen zo generisch mogelijk te werken. Dit heeft als indirect gevolg dat de koppeling in ons domeinmodel zeer laag is. Immers dient bij een generische implementatie abstractie gemaakt te worden van de details in de ongekende subklassen. Bijgevolg zijn enkel koppelingen zoals deze tussen \verb+Emergency+ en \verb+Unit+, of naar de klassen van hun attributen van belang.
\paragraph{}
Het polymorfisme dient vervolgens de ontbrekende details in te vullen. E\'en concreet voorbeeld hiervan is de \verb+calculateUnitsNeeded()+ methode. Hierbij dient een specifiek type \verb+Emergency+ zelf uit te maken welke en hoeveel units er naar deze emergency gestuurd moeten worden. Dit beantwoordt bovendien ook aan het Information Expert patroon. Een Emergency zelf weet immers het best hoe er gereageerd dient te worden.
\paragraph{}
Ook hebben we zoveel mogelijk attributen proberen te groeperen in enumeraties. Zo hebben we bijvoorbeeld een \verb+EmergencyStatus+, \verb+EmergencySeverity+ en \verb+FireSize+. Dit heeft als gevolgd dat wanneer er bijvoorbeeld nog een nieuwe status toegevoegd wordt dat we niks een \verb+Emergency+ zelf moeten veranderen. Dit is een voorbeeld van protected variation. Een ander voorbeeld hiervan is onze interface \verb+TimeSensitive+. \verb+TimeSensitive+ zegt dat heb object die deze interface implementeert afhankelijk is van de tijd. Voorlopig zijn dat enkel objecten van de klasse \verb+Unit+. Maar als er in de toekomst een ziekenhuis tijdsafhankelijk wordt dan kan dit ziekenhuis eenvoudig deze interface implementeren.
\paragraph{}
Een voorbeeld van pure fabrication is de klasse \verb+UnitsNeeded+. Deze klasse heeft als verantwoordelijkheid de gevraagde units voor een emergency op te slaan en ze eventueel naar de emergency te sturen wanneer dit gevraagd is. Aangezien de cohesie daalt wanneer de units verantwoordelijk zijn voor hun assignatie aan de emergency of als de emergency zelf zijn units moet kiesen, hebben we gekozen om een aparte klasse aan te maken die deze verantwoordelijkheid draagt. \verb+UnitsNeeded+ zorgt er ook voor dat er geen directe koppeling is tussen \verb+Emergency+ en \verb+Unit+. Dit moet feitelijk ook niet aangezien een emergency bepaalde types units vereist en niet een unit zelf.
\paragraph{} Een voorbeeld van het protected variation patroon is de klasse \verb+EmergencyEvaluationCriterium+ en zijn kind \verb+StatusEqualityEmergencyEvaluationCriterium+. Dit zijn klassen die een zoekoperatie kunnen uitvoeren op een emergency. Aangezien er feitelijk op elke mogelijke combinatie van de attributen van emergency een zoekoperatie bestaat hebben we een algemene klasse \verb+EmergencyEvaluationCriterium+. Deze stelt gewoon een zoekoperatie voor. De zoekoperatie zelf wordt dan gespecifieerd in een kind van deze klasse.
\paragraph{}
Voorbeelden van het controller pattern zijn er ook genoeg. Namelijk heel de package \verb+projectswop20102011.controllers+. Deze dienen als koppeling tussen de user interface en het feitelijke systeem. Aangezien een controller maar heel weinig mag doen zijn de meeste controllers dan ook heel kort. Methodes van twee zijn zowat de grootste die er bestaan.
\paragraph{}
Ook hebben we systematisch een lijst-klasse gemaakt wanneer er een klasse verbonden moet worden met \verb+World+. Zo hebben we \verb+EmergencyList+, \verb+UnitBuildingList+ en \verb+TimeSensitiveList+. Zoals de namen al doen vermoeden groeperen deze klassen objecten van dezelfde klasse. Zo bevat \verb+EmergencyList+ een lijst van emergencies, \verb+UnitBuildingList+ een lijst van unitbuildings enzovoort. We hebben dit gedaan zodat \verb+World+ niet te veel verantwoordelijkheden zou hebben. Zo is het niet de bedoeling dat \verb+World+ een sortering moet uitvoeren op zijn emergencies. Tevens is dit ook niet de verantwoordelijkheid van een emergency zelf. Dus de --- volgens ons --- eleganste oplossing was een nieuwe klasse tussen \verb+World+ en \verb+Emergency+ steken. Deze klasse heeft dan als verantwoordelijkheid de emergencies op te slaan en eventueel operaties op deze lijst uit te voeren. Het is niet de bedoeling dat \verb+EmergencyList+ operaties op \verb+Emergency+ zelf gaat uitvoeren. \verb+UnitBuildingList+ en \verb+TimeSensitiveList+ hebben we analoog aangepakt. Dit is dus een voorbeeld van pure fabrication met als gevolgd dat de cohesie stijgt. Ook zit er voor een stuk het indirection pattern in.
\subsection{Uitgewerkte alternatieven}
Naast dit model werden verschillende andere modellen bestudeerd. Bovendien kwam dit model ook met een zekere evolutie tot stand. Modellen werden ge\"implementeerd, met een kritische blik op het ontstaan van problemen. Frequent werd dan ook het model herbekeken en aangepast. In deze sectie geven we een bondig overzicht van de belangrijkste overwogen alternatieven.
\paragraph{Domeinmodel versus klassendiagram}
Het domeinmodel in de opgave suggereert heel vaak dat bepaalde klassen ge\"implementeerd dienen worden, zoals bijvoorbeeld de klassen \verb+Caller+ en \verb+Call+. Deze werden initieel ge\"implementeerd. Er staat echter in geen enkele use case beschreven dat het bijhouden van deze instanties vereist is. Eenvoud ligt immers aan de basis van een goed model. Het ligt in de geest van Extreme Programming om geen functionaliteiten te schrijven die geen duidelijk nut hebben. Bijgevolg werd besloten deze klassen te verwijderen. Bovendien werd de implementatie zo vereenvoudigd. Iets soortgelijks gebeurde met de klassen \verb+Operator+, \verb+Dispatcher+ en \verb+UnitCommander+. Deze klassen zijn niet volledig verdwenen uit ons model want er bestaan nog controllers voor.
\paragraph{Polymorfisme versus typeattribuut}
Een belangrijke overweging in het model was het design van een \verb+Unit+ en de bijbehorende types eenheden. Hierbij werden drie overwegingen onderzocht. De eerste mogelijkheid was --- zoals het domeinmodel suggereert --- een polymorfe aanpak. Hierbij worden klassen als \verb+Ambulance+ onder de klasse \verb+Unit+ geplaatst. Deze implementatie leidt echter tot klassen zonder inhoud. Zo erven \verb+Firetruck+ en \verb+Policecar+ alle methodes over. Maar dit model heeft geen toegevoegde waarde. De enige informatie die een \verb+Policecar+ meer bevat dan een \verb+Unit+ is zijn typeinformatie. Een alternatief werd gerealiseerd door middel van een typeattribuut. Een enumeratie \verb+UnitType+ bevat de drie verschillende types eenheden. Een \verb+Unit+ bevat vervolgens een associatie met een \verb+UnitType+. Dit model werkt echter niet, omdat een \verb+Ambulance+ wel extra informatie bevat. Het dient immers een hospitaal te kunnen selecteren. Optionele attributen zijn hierbij uit den boze omdat ze de cohesie verlagen. Bovendien druisen ze in tegen normalisatieprincipes uit bijvoorbeeld databanken. De derde onderzochte vorm was een hybride tussen de twee vorige. Hierbij werken we met polymorfisme, maar bevat \verb+Unit+ ook een typeattribuut. Dit model gaat echter in tegen heel wat principes: er ontstaat redundantie, protected variation wordt geschonden, de cohesie daalt en er ontstaan meer koppelingen. We opteerden bijgevolg voor de eerste mogelijkheid.
\paragraph{}
