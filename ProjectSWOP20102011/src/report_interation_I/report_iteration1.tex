\documentclass[a4paper, titlepage,12pt]{article}

\usepackage{fullpage}
\usepackage[dutch]{babel}
\usepackage[final]{graphicx}
\usepackage{tikz}
\usepackage{float}
\usepackage{color}
\usepackage{listings}
\usepackage{multirow}

%\definecolor{darkgreen}{rgb}{0,0.4,0}

\title{Software Ontwerp - Verslag Iteratie 1}
\author{Willem Van Onsem\\Jonas Vanthornhout\\Pieter-Jan Vuylsteke}
\date{10 november 2010}

\begin{document}
\begin{titlepage}
\maketitle
\end{titlepage}

\tableofcontents
\newpage
\section*{Introductie}
Het verslag is als volgt gestructureerd. In sectie \ref{overzicht} geven we een overzicht van het systeem en zijn subsystemen.
We tonen ook hoe we de verschillende verantwoordelijkheden hebben toegewezen.
In sectie \ref{grasp} bespreken we de invloed van GRASP principes op ons ontwerp.
Alternatieve ontwerpen die niet gekozen werden, zullen ook vermeld worden.
De mogelijkheden die voorzien zijn voor uitbreidingen zullen besproken worden in sectie \ref{uitbreidbaarheid}.
Vervolgens tonen we in sectie \ref{testen} hoe we onze testen hebben aangepakt.
In sectie \ref{projectbeheer} vermelden we hoe we de verschillende taken hebben verdeeld onder de groepsleden
en hoeveel tijd er werd besteed aan deze taken.
Ten slotte besluiten we in sectie \ref{besluit} door o.a. enkele problemen te schetsen die we zijn tegengekomen.

\newpage
\section{Overzicht van het systeem}
\label{overzicht}
We deelden het project op in 5 verschillende packages:
\begin{itemize}
 \item de domein package (\verb+projectswop20102011+)
 \item de exception package (\verb+projectswop20102011.exceptions+)
 \item de factory package (\verb+projectswop20102011.factories+)
 \item de controller package (\verb+projectswop20102011.controllers+)
 \item de userinterface package (\verb+projectswop20102011.userinterface+)
\end{itemize}
Deze opdeling gebeurde om de verschillende lagen van elkaar te scheiden, waarbij het domein package enkel van de exceptions afhankelijk is. Dit betekent dat het bestaan van klassen in de domeinlaag niet afhangt van het bestaan van klassen in de factory, controller en userinterface laag.
\paragraph{}
We zullen nu de verschillende lagen meer in detail bespreken. Centraal in de domeinlaag bevindt zich uiteraard de klasse \verb+Emergency+. Onder deze klasse komen dan de verschillende types emergencies, die elk een subklasse vormen, met hun specifieke attributen. Elk van deze emergency types heeft een eigen factory, een object die in staat is deze emergencies aan te maken. Hiermee proberen we tegemoet te komen aan mogelijke aanpassingen/toevoegingen van emergencies, waarbij we enkel een factory moeten toevoegen of aanpassen. Deze emergencies worden vervolgens bijgehouden in een \verb+EmergencyList+, dit is een set van verschillende emergencies. Op deze set kan men queries uitvoeren met behulp van een \verb+EmergencyEvaluationCriterium+. Deze abstracte klasse valideert emergencies, waarbij de geslaagde emergencies de nieuwe elementen in een nieuwe \verb+EmergencyList+ worden. Hierdoor zijn we op een eenvoudige manier in staat complexe queries uit te voeren. Een andere belangrijke klasse in de domeinlaag is de \verb+Unit+. Deze abstracte klasse houdt een bepaalde eenheid bij, namelijk een \verb+Firetruck+, \verb+Ambulance+ of \verb+Policecar+. Deze units worden vervolgens aan een bepaalde \verb+Emergency+ toegewezen. Een belangrijk aspect is hierbij dat we geen klassen als \verb+Caller+ of \verb+Call+ of \verb+Operator+ implementeren. Immers wordt nergens in een use case gespecifieerd wat het mogelijke nut hiervan zou zijn. Bovendien impliceert iedere implementatie bijkomende voorwaarden op het model, wat de uitbreidbaarheid niet ten goede komt.
\paragraph{}
De factory package is de hoeksteen van de uitbreidbaarheid van ons model. Dit abstract factory patroon laat ons toe om dynamisch nieuwe typen emergencies en units toe te voegen. Dit zonder andere delen van het model aan te passen. Dit concept wordt zowel voor emergencies als \verb+UnitBuilding+s toegepast. In het eerste geval om de creatie van emergencies door de actor operator generisch te doen verlopen. In het tweede geval voor het laden van de omgeving.
\paragraph{}
Tot slot bevat de controller package alle controllers die de domeinlaag aansturen. Hierbij beschouwen we een abstracte klasse \verb+Controller+. Hierdoor hebben alle controllers een link naar het \verb+World+ object. Dit is een object die het hele domein bijhoudt, waardoor de controllers dit kunnen aanpassen. De controllers zijn behoorlijk gelijklopend met de use cases, waarbij ook voor de initialisatie van de omgeving een aparte controller werd geschreven. In de exception package worden de verschillende exception klassen beschreven en analoog wordt in de userinterface package de userinterface beschreven.
\newpage
\section{Invloed van GRASP patterns}
\label{grasp}
\subsection{Bespreking van het systeem}
In onze implementatie proberen we in de meeste gevallen zo generisch mogelijk te werken. Dit heeft als indirect gevolg dat de koppeling in ons domeinmodel zeer laag is. Immers dient bij een generische implementatie abstractie gemaakt te worden van de details in de ongekende subklassen. Bijgevolg zijn enkel koppelingen zoals deze tussen \verb+Emergency+ en \verb+Unit+, of naar de klassen van hun attributen van belang.
\paragraph{}
Het polymorfisme dient vervolgens de ontbrekende details in te vullen. E\'en concreet voorbeeld hiervan is de \verb+calculateUnitsNeeded()+ methode. Hierbij dient een specifiek type \verb+Emergency+ zelf uit te maken welke en hoeveel units er naar deze emergency gestuurd moeten worden. Dit beantwoordt bovendien ook aan het Information Expert patroon. Een Emergency zelf weet immers het best hoe er gereageerd dient te worden.
\paragraph{}
\subsection{Uitgewerkte alternatieven}
Naast dit model werden verschillende andere modellen bestudeerd. Bovendien kwam dit model ook met een zekere evolutie tot stand. Modellen werden ge\"implementeerd, met een kritische blik op het ontstaan van problemen. Frequent werd dan ook het model herbekeken en aangepast. In deze sectie geven we een bondig overzicht van de belangrijkste overwogen alternatieven.
\paragraph{\texttt{Caller} en \texttt{Call}}
Het domeinmodel in de opgave suggereert heel vaak dat bepaalde klassen ge\"implementeerd dienen worden, zoals bijvoorbeeld de klassen \verb+Caller+ en \verb+Call+. Deze werden initieel ge\"implementeerd. Er staat echter in geen enkele use case beschreven dat het bijhouden van deze instanties vereist is. Eenvoud ligt immers aan de basis van een goed model. Het ligt in de geest van Extreme Programming om geen functionaliteiten te schrijven die geen duidelijk nut hebben. Bijgevolg werd besloten deze klassen te verwijderen. Bovendien werd de implementatie zo vereenvoudigd.
\paragraph{Polymorfisme versus typeattribuut}
%Bijhorende <=> bijbehorende
Een belangrijke overweging in het model was het design van een \verb+Unit+ en de bijbehorende types eenheden. Hierbij werden drie overwegingen onderzocht. De eerste mogelijkheid was --- zoals het domeinmodel suggereert --- een polymorfe aanpak. Hierbij worden klassen als \verb+Ambulance+ onder de klasse \verb+Unit+ geplaatst. Deze implementatie leidt echter tot klassen zonder inhoud. Zo erven \verb+Firetruck+ en \verb+Policecar+ alle methodes over. Maar dit model heeft geen toegevoegde waarde. De enige informatie die een \verb+Policecar+ meer bevat dan een \verb+Unit+ is zijn typeinformatie. Een alternatief werd gerealiseerd door middel van een typeattribuut. Een enumeratie \verb+UnitType+ bevat de drie verschillende types eenheden. Een \verb+Unit+ bevat vervolgens een associatie met een \verb+UnitType+. Dit model werkt echter niet, omdat een \verb+Ambulance+ wel extra informatie bevat. Het dient immers een hospitaal te kunnen selecteren. Optionele attributen zijn hierbij uit den boze omdat ze de cohesie verlagen. Bovendien druisen ze in tegen normalisatieprincipes uit bijvoorbeeld databanken. De derde onderzochte vorm was een hybride tussen de twee vorige. Hierbij werken we met polymorfisme, maar bevat \verb+Unit+ ook een typeattribuut. Dit model gaat echter in tegen heel wat principes: er ontstaat redundantie, protected variance, high cohesion en low coupling. We opteerden bijgevolg voor de eerste mogelijkheid.
\paragraph{}

%TO BE REMOVED
\newpage{}
\paragraph{}
\verb+DIT IS EEN STUK IN HET KLAD(CORRECTHEID IS NIET GEGARANDEERD)+\\
We zijn voor het model waarin ambulance, firetruck, policecar overerven van unit. Dit omdat meer aan het patroon van high cohesian voldaan wordt. Als we een enum aanmaken van unit type, dan wordt de klasse Unit heel groot (met geen high cohesion) omdat alle methodes voor iedere 'sub'unit moeten geimplementeerd worden in dezelfde klasse.\\\\
De klasse UnitsNeeded wordt gebruik om high cohesian te bevorderen. Dit zorgt ervoor dat de klasse Emergency niet zwaarder wordt belast.\\\\
Emergency is the Information Expert
\newpage
\section{Uitbreidbaarheid}
\label{uitbreidbaarheid}
Het project is gebouwd vanuit het idee dat het project enkele standaard aanpassingen moet kunnen verwerken, zonder veel code te wijzigen. Een voorbeeld hiervan is de implementatie van de emergencies, waarbij men zelfs de creatie van de Emergency op een generische manier in de user interface tracht te behandelen. Een oorzaak van deze uitbreidbaarheid is Low Coupling. Immers houdt Low Coupling in dat veranderingen op bepaalde plaatsen maar zeer beperkt effect hebben op de code op andere plaatsen. Uitbreidbaarheid streeft dus in sommige gevallen naar hetzelfde als de GRASP Patterns.
\paragraph{}
Welke uitbreidingen hebben we dan in gedachten? In de eerste plaats doet het model ons vermoeden dat de types Emergencies wel eens uitgebreid kunnen worden. De lijst van emergencies was immers beperkt. In het geval we een nieuw type emergency willen toevoegen. Indien we een vulkaanuitbarsting toevoegen, hoeven we immers alleen een subklasse \verb+VolcanicEruption+ te implementeren, en een bijbehorende factory, \verb+VolcanicEruptionFactory+ toe te voegen aan onze lijst van Emergency factories. Indien deze vulkaanuitbarsting geen extra types argumenten bevat die nog niet gekend zijn, hoeft verder helemaal geen code geschreven te worden. Indien we wel nieuwe types parameters toevoegen, zoals het type vulkaan, hoeven we alleen een klasse \verb+VolcanoType+ in onze domeinlaag te implementeren, en een \verb+VolcanoTypeParser+ te schrijven in onze userinterfacelaag. Dergelijk model leidt tot zeer lage koppeling. Immers dient geen andere klasse in de domeinlaag van het bestaan van een vulkaanuitbarsting af te weten. Er wordt dus abstractie gemaakt van het type Emergency.
\subparagraph{}
Een analoge uitbreiding is deze van de \verb+UnitBuilding+ types. Opnieuw kunnen we hier met een gelijkaardig scenario eenvoudig een extra \verb+Unit+ of \verb+Building+ toe te voegen.
\paragraph{}
Ook de userinterface kan verder uitgebreid worden. Hierbij wordt door middel van polymorfisme een framework geleverd, waarbij men makkelijk nieuwe commando's kan toevoegen. Daar we er vanuit gaan dat het aantal use cases nog zal toenemen, is het aanbieden van dergelijke klassen dus te rechtvaardigen.
\newpage
\section{Aanpak voor het testen}
\label{testen}
Om het ontwerp van de testen te illustreren, zullen we dit illustreren met behulp van een voorbeeld.

\newpage
\section{Projectbeheer}
\label{projectbeheer}
\begin{table}[H]
\centering
\begin{tabular}{|llr|}
\hline
Naam&Type van taak&Duur\\
\hline
\hline
\multirow{3}{*}{Willem Van Onsem}&Implementeren&3h\\
&Schrijven van testcases&1h\\
&Ontwerp&5h\\
\hline
Jonas Vanthornhout&&\\
\hline
Pieter-Jan Vuylsteke&&\\
\hline
\end{tabular}
\caption{Tijd ge\"investeerd door de teamleden}
\label{tbl:timeUsage}
\end{table}
\newpage
\section{Besluit}
\label{besluit}
\newpage
\nocite{*}
\bibliographystyle{alpha}
\bibliography{boeken}
\end{document}

\end{document}