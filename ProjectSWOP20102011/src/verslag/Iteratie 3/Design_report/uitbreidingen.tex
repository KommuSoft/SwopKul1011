\label{uitbreidbaarheid}
Het project is gebouwd vanuit het idee dat we enkele standaard aanpassingen moeten kunnen verwerken, zonder veel code te wijzigen. Een voorbeeld hiervan is de implementatie van de emergencies. Een gevolg van deze uitbreidbaarheid is \textit{Low Coupling}. Immers houdt \textit{Low Coupling} in dat veranderingen op bepaalde plaatsen maar zeer beperkt effect hebben op de code op andere plaatsen. Uitbreidbaarheid streeft dus in sommige gevallen naar hetzelfde als de GRASP Patterns.

\paragraph{}
Welke uitbreidingen hebben we dan in gedachten? In de eerste plaats doet het model ons vermoeden dat de types Emergencies wel eens uitgebreid kunnen worden. De lijst van emergencies is immers beperkt. In het geval dat we een nieuw type \texttt{Emergency} willen toevoegen, bijvoorbeeld een vulkaanuitbarsting, hoeven we immers alleen een subklasse \texttt{VolcanicEruption} te implementeren. Meestal volstaat het enkele methodes zoals bijvoorbeeld de methode \texttt{Emergency.calculateUnitsNeeded()} te implementeren. Er wordt dus tot op zeker niveau abstractie gemaakt van het type \texttt{Emergency}. Bovendien werd met behulp van het \textit{Factory Method-Pattern} de constructie van een \texttt{Emergency} generisch opgelost. De programmeur dient enkel een extra \texttt{Factory} te implementeren en eventueel extra \texttt{Parsers}. Het omzetten van een commando naar een nieuwe \texttt{Emergency} gebeurt dan volledig autonoom. Verder worden de belangrijkste associaties op een hoog niveau gelegd, waardoor we van de specifieke \texttt{Emergency} abstractie kunnen maken. Een analoge uitbreiding is deze van de \texttt{MapItem} types. Opnieuw kunnen we hier met een gelijkaardig scenario eenvoudig een extra \texttt{Unit} of gebouw toe te voegen.

\paragraph{}
Ook de userinterface kan verder uitgebreid worden. Hierbij wordt door middel van \textit{Polymorphism} een framework geleverd, waarbij men makkelijk nieuwe commando's kan toevoegen. Daar we ervan uitgaan dat het aantal use cases nog zal toenemen, is het aanbieden van dergelijke klassen dus te rechtvaardigen. Bovendien verkleint het de kans op fouten, in bijvoorbeeld het weergeven van de lijst van commando's.

\paragraph{}
Zoals reeds gezegd gebruiken we voor de \texttt{DispatchPolicy} een \textit{Chain Of Responsibilities}. Dit laat ons toe om eenvoudig bestaande deelpolicies te recycleren en bijvoorbeeld de prioriteit aan te passen. Ook kunnen nieuwe bouwstenen makkelijk toegevoegd worden, zonder complexe algoritmen te implementeren.

\paragraph{}
Zoals reeds kort aangehaald zijn de \texttt{DispatchUnitsConstraint} makelijk zeer generisch uit te breiden. We implementeerden slechts twee types. De programmeur bezit echter alle vrijheid om totaal nieuwe soorten constraints te ontwikkelen.
\paragraph{}
Heel wat code in dit project is overbodig en levert geen bijdrage. Meestal echter heeft dit tot doel om in geval van nieuwe specificaties makkelijk de nieuwe feiten te implementeren. Dit wordt verwezenlijkt door het invoeren van een abstract niveau alvorens de uiteindelijk implementatie te schrijven. Een concreet voorbeeld is de \texttt{Emergency\-Evaluation\-Criterium} klasse. Hierbij wordt een abstractieniveau ge\"implementeerd voor het selecteren van emergencies op een bepaald criterium, bijvoorbeeld de status. Deze aanpassing heeft echter ook andere redenen, bijvoorbeeld omwille van het \textit{Information Expert} GRASP pattern. Abstractie impliceert verder ook \textit{Low Coupling}, wat dus het model opnieuw ten goede komt.
\paragraph{}
We werken ook met een \texttt{TimeSensitive} interface. In het huidige model zouden we deze functionaliteit enkel op \texttt{Unit} niveau kunnen aanbieden, door deze interface, kunnen we eenvoudig andere klassen ook tijdsgevoelig maken.