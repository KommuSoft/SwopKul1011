\label{patterns}
\section{Invloed van GRASP patterns}
\subsection{GRASP patterns}
\subsubsection{Bespreking van het systeem}
\paragraph{Algemeen}
In onze implementatie proberen we in de meeste gevallen zo generisch mogelijk te werken. Dit heeft als indirect gevolg dat de koppeling in ons domeinmodel zeer laag is. Immers dient bij een generische implementatie abstractie gemaakt te worden van de details in de ongekende subklassen. Bijgevolg zijn enkel koppelingen zoals deze tussen \texttt{Emergency} en \texttt{Unit}, of naar de klassen van hun attributen van belang.
\paragraph{Polymorphism}
Het pattern \textit{Polymorphism} dient vervolgens de ontbrekende details in te vullen. E\'en concreet voorbeeld hiervan is de \texttt{Emergency.calculateUnitsNeeded()} methode. Hierbij dient een specifiek type \texttt{Emergency} zelf uit te maken welke en hoeveel units er naar deze \texttt{Emergency} gestuurd moeten worden. Dit beantwoordt bovendien ook aan het \textit{Information Expert} patroon. Een Emergency zelf weet immers het best hoe er gereageerd dient te worden.
\paragraph{}
Ook hebben we zoveel mogelijk attributen proberen te groeperen in enumeraties. Zo hebben we bijvoorbeeld een \texttt{EmergencyStatus}, \texttt{EmergencySeverity} en \texttt{FireSize}. Dit heeft tot gevolg dat indien er bijvoorbeeld een nieuwe status toegevoegd wordt aan het model, we niets aan de \texttt{Emergency} zelf moeten veranderen. Dit is een voorbeeld van \textit{Protected Variation}. Een ander voorbeeld hiervan is onze interface \texttt{TimeSensitive}. \texttt{TimeSensitive} zegt dat het object die deze interface implementeert, afhankelijk is van de tijd. Voorlopig zijn dat enkel objecten van de klasse \texttt{Unit}. Maar als in de toekomst een \texttt{Hospital} tijdsafhankelijk wordt, dan kan dit ziekenhuis eenvoudig deze interface implementeren. Analoog werkt dit uiteraard ook voor bijvoorbeeld \texttt{Emergency}.
\paragraph{}
Een voorbeeld van \textit{Pure Fabrication} is de klasse \texttt{UnitsNeeded}. Deze klasse is verantwoordelijk voor het opslaan van de vereiste aantallen eenheden voor een \texttt{Emergency}. En vervolgens het toewijzen van die eenheden te beheren. De \textit{Cohesion} daalt immers wanneer de units verantwoordelijk zijn voor hun toewijziging aan de \texttt{Emergency}, of indien de \texttt{Emergency} zelf zijn units moet kiezen. Daarom hebben we ervoor gekozen een aparte klasse aan te maken die deze verantwoordelijkheid draagt. \texttt{UnitsNeeded} zorgt er ook voor dat er geen directe koppeling is tussen \texttt{Emergency} en \texttt{Unit}. Dit moet feitelijk ook niet aangezien een emergency bepaalde types units vereist en niet een unit zelf.
\paragraph{} Een voorbeeld van het \textit{Protected Variation} patroon is de klasse \texttt{Emergency\-Evaluation\-Criterium} en haar kind \texttt{StatusEqualityEmergencyEvaluationCriterium}. Dit zijn klassen die een zoekoperatie kunnen uitvoeren op een emergency. Aangezien er feitelijk op elke mogelijke combinatie van de attributen van emergency een zoekoperatie bestaat hebben we een algemene klasse \texttt{EmergencyEvaluationCriterium} ge\"implementeerd. Deze stelt gewoon een zoekoperatie voor. De zoekoperatie zelf wordt dan gespecifieerd in een kind van deze klasse.
\paragraph{}
Voorbeelden van het \textit{Controller} patroon zijn er ook genoeg. Namelijk heel de package \texttt{projectswop201-}\\\texttt{02011.controllers}. Deze dienen als koppeling tussen de user interface en het feitelijke systeem. Aangezien een controller maar heel weinig functionaliteit mag bezitten, zijn deze klassen dan ook bijzonder kort.
\paragraph{}
Ook hebben we systematisch een lijst-klasse gemaakt wanneer er een klasse verbonden moet worden met \texttt{World}. Zo hebben we \texttt{EmergencyList}, \texttt{MapItemList} en \texttt{TimeSensitiveList}. Zoals de namen al doen vermoeden, groeperen deze lijsten objecten van een gelijknamige klasse. Zo bevat \texttt{EmergencyList} een lijst van emergencies, \texttt{MapItemList} een lijst van \texttt{MapItem}s enzovoort. Hierdoor heeft de klasse \texttt{World} een minimaal aantal verantwoordelijkheden. Zo is het niet de bedoeling dat \texttt{World} een sortering moet uitvoeren op zijn emergencies. Tevens is dit ook niet de verantwoordelijkheid van een emergency zelf. Een elegante oplossing is een nieuwe klasse tussen \texttt{World} en \texttt{Emergency} toevoegen. Deze klasse heeft dan als verantwoordelijkheid de emergencies op te slaan en eventueel operaties op deze lijst uit te voeren. Het is niet de bedoeling dat \texttt{EmergencyList} operaties op \texttt{Emergency} zelf gaat uitvoeren. \texttt{MapItemList} en \texttt{TimeSensitiveList} hebben we analoog ge\"implementeerd. Dit is dus een voorbeeld van \textit{Pure Fabrication} met als gevolg dat de \textit{Cohesion} stijgt. Ook het \textit{Indirection} patroon is hier gedeeltelijk aan de orde.
\subsection{Design patterns}
\subsubsection{Composite}
\paragraph{}
We stellen onze constraints op onze emergency voor als een boom. Deze implementatie is een toepassing van het \textit{Composite} pattern. Hierbij zien we \texttt{Dispatch\-Units\-Constraint} in de rol van \texttt{Component} en de \texttt{Number\-Dispatch\-Units\-Constraint} is \'e\'en van de eventueel later uitgebreide \texttt{Leaf}s. Tot slot zien we \texttt{And\-Dispatch\-Units\-Constraint} als de \texttt{Composite} klasse. Gegeven de specificaties in de opgave is dergelijke structuur misschien ``overkill''. We zijn echter makkelijk in staat om nieuwe types constraints toe te voegen, net als connectoren (zoals bijvoorbeeld een OR). Het uitgewerkte UML diagram met de relevante methodes staat op figuur \ref{fig:compositePattern}.
\begin{figure}[h!]
\includegraphics[width=1.0\textwidth]{CD_compositePattern.pdf}
\caption{UML diagram van de implementatie van het \textit{Composite}-pattern in het project.}
\label{fig:compositePattern}
\end{figure}
Tot slot kan opgemerkt worden dat in het boek er operaties in de Composite-participant gedefinieerd worden. In deze implementatie voegen we eenvoudigweg geen operaties toe. Het kennen van de parent levert voor \verb+AndDispatchUnitsConstraint+ geen meerwaarde op. Verder kan geargumenteerd worden dat de opbouw van de boom hiermee vastligt: bottom-up, er kan dus bijgevolg geen boom met een tak naar zichzelf bestaan. Tot slot zou het ook kunnen betekenen dat een component op veschillende plaatsen in de boom voorkomt, wat de structuur dus meer dynamiek geeft.
\subsubsection{State}
Hoewel we geen \verb+cancel+-emergency use case moesten implementeren, anticipeerden we toch op de creatie van nieuwe staten waarin een emergency zich kan bevinden. We modelleerden dan ook een toestandsdiagram zoals op figuur \ref{fig:stateDiagramEmergency}.
\begin{figure}[h!]
\centering
\begin{tikzpicture}
\node[rectangle,draw=black] (RBU) at (0,0) {Recorded but unhandled};
\node[rectangle,draw=black] (RIP) at (6,0) {Response in progress};
\node[rectangle,dashed,draw=black] (Cl) at (6,-3.2) {Cancelled};
\node[rectangle,draw=black] (C) at (12,0) {Completed};
\draw[->] (RBU) to node[above,midway]{\small\texttt{assignUnits}} (RIP);
\draw[->] (RIP.east) -| ++(0.5,1) -- ++(-1.0) -| (RIP.north);
\draw[->] (RIP) to node[above,midway]{\small\texttt{finishUnit}} (C);
\draw[dashed,->] (BRU) -- ++(0,-3.2) to node[above,midway]{\small\texttt{cancelEmergency}} (Cl);
\draw[dashed,->] (RIP) to node[above,midway,sloped]{\small\texttt{cancelEmergency}} (Cl);
\end{tikzpicture}
\caption{Beschrijving van de toestanden en overgangen van Emergency}
\label{fig:stateDiagramEmergency}
\end{figure}
Anderzijds willen we de voordelen die een \verb+enum+ ons biedt niet verliezen\footnote{Zoals bijvoorbeeld een opsomming van de verschillende toestanden.}. Daarom opteerden we voor een hybride structuur. Deze structuur behoudt in zekere zin de geest van het \textit{State}-pattern beschreven in het boek \cite{book:designpatterns}. In \verb#C++# zijn \verb+enum+s echter niet polymorf: het is een lijst van sleutels die met een binaire waarde geassocieerd worden. In java kunnen elementen in een enumeratie in zekere zin als een singleton-subklasse van de enumeratie beschouwd worden\footnote{Uiteraard gaat die vergelijking niet volledig op.}. Het gevolg is dat we ook methodes aan deze elementen kunnen toewijzen en dus individueel anders kunnen implementeren.
\begin{figure}[h!]
\includegraphics[width=1.0\textwidth]{CD_statePattern.pdf}
\caption{UML diagram van de implementatie van het \textit{State}-pattern in het project.}
\label{fig:statePattern}
\end{figure}
Het grote nadeel van deze methode is dat alle toestanden zichtbaar zijn. Indien we dus later in het project juist een toestand willen implementeren waarover we niet kunnen filteren zal deze implementatie grondig bekeken moeten worden. Verder biedt deze implementatie alle voordelen van het \textit{State}-pattern en een \verb+enum+.
\subsubsection{Factory Method}
Omdat units en emergencies vaak aangemaakt worden met behulp van een tekstbestand, leek het ons nuttig om hiervoor een \textit{Factory Method}-pattern te gebruiken. Op die manier kunnen we dan een set van factories bijhouden, waarbij iedere factorie een bepaald directief bijhoudt. Indien bij het inlezen van het tekstbestand een directief wordt ingelezen, zal de bijbehorende factory uit de set gehaald worden, die dan vervolgens een unit of emergency aanmaakt. Hierbij werden we echter geconfronteerd met een belangrijk probleem: de parameters van de verschillende units of emergencies zijn niet uniform. We kunnen dus bijgevolg geen abstracte factorylaag bouwen waarbij de parameters gespecifieerd zijn. Dit losten we echter op door een lijst van objecten als parameter mee te geven. Parameters die wel bekend waren\footnote{Omdat ze in de constructor van bijvoorbeeld \texttt{Emergency} reeds gedefinieerd zijn.} werden uiteraard wel in de methode signatuur opgenomen. Dit probleem werd op verschillende constructie patterns bestudeerd, maar werd nergens concreet opgelost\footnote{Een prototype kan dit misschien wel oplossen, maar ons domein zou hierop fout kunnen reageren, vanwege finale velden. Bovendien gaan sommige methodes uit van deze finale velden}. De implementatie is beschreven op figuur \ref{fig:factoryMethodPattern}.
\begin{figure}[h!]
\includegraphics[width=1.0\textwidth]{CD_factoryMethodPattern.pdf}
\caption{UML diagram van de implementatie van het \textit{Factory Method}-pattern in het project.}
\label{fig:factoryMethodPattern}
\end{figure}
\subsubsection{Strategy}
Om units terug te trekken van een emergency hebben we het \textit{Strategy} pattern toegepast. In de opgave zijn er twee mogelijke manieren. Ofwel mag een unit zich terugtrekken, mits hij aan bepaalde voorwaarden voldoet. Ofwel mag deze zich nooit terugtrekken. Het voordeel van het \textit{Strategy} pattern is dat we eenvoudig nieuwe manieren van terugtrekken kunnen toevoegen door een nieuwe subklasse van \texttt{WithdrawBehavior} toe te voegen. Ook als er nieuwe soorten units toegevoegd worden, hoeven we niet steeds de hele withdraw methode te kopi\"eren.
\begin{figure}[h!]
\includegraphics[width=1.0\textwidth]{WithdrawStrategyPattern.pdf}
\caption{UML diagram van de implementatie van het \textit{Strategy} pattern bij het terugtrekken van units.}
\label{fig:withdrawStrategyPattern}
\end{figure}
\subsection{Uitgewerkte alternatieven}
Naast dit model werden verschillende andere modellen bestudeerd. Bovendien kwam dit model ook met een zekere evolutie tot stand. Modellen werden ge\"implementeerd met een kritische blik op het ontstaan van problemen. Frequent werd dan ook het model herbekeken en aangepast. In deze sectie geven we een bondig overzicht van de belangrijkste overwogen alternatieven.
\paragraph{Domeinmodel versus klassendiagram}
Het domeinmodel in de opgave suggereert heel vaak dat bepaalde klassen dienen ge\"implementeerd te worden. Voorbeelden hierbij zijn de klassen \texttt{Caller} en \texttt{Call}. Deze werden initieel ge\"implementeerd. Er staat echter in geen enkele use case beschreven dat het bijhouden van deze instanties vereist is. Het ligt in de geest van Extreme Programming om geen functionaliteiten te schrijven die geen duidelijk nut hebben. Eenvoud ligt immers aan de basis van een goed model. Bijgevolg werd besloten deze klassen te verwijderen. Bovendien werd de implementatie zo vereenvoudigd. Iets soortgelijks gebeurde met de klassen \texttt{Operator}, \texttt{Dispatcher} en \texttt{UnitCommander}. Deze klassen zijn niet volledig verdwenen uit ons model want er bestaan nog controllers voor.
\paragraph{Polymorfisme versus typeattribuut}
Een belangrijke overweging in het model was het design van een \texttt{Unit} en de bijbehorende types eenheden. Hierbij werden drie overwegingen onderzocht. De eerste mogelijkheid was --- zoals het domeinmodel suggereert --- een polymorfe aanpak. Hierbij worden klassen als \texttt{Ambulance} onder de klasse \texttt{Unit} geplaatst. Deze implementatie leidt echter tot klassen zonder inhoud. Zo erven \texttt{Firetruck} en \texttt{Policecar} alle methodes over. Maar dit model heeft geen toegevoegde waarde. De enige informatie die een \texttt{Policecar} meer bevat dan een \texttt{Unit} is zijn typeinformatie. Een alternatief werd gerealiseerd door middel van een typeattribuut. Een enumeratie \texttt{UnitType} bevat de drie verschillende types eenheden. Een \texttt{Unit} bevat vervolgens een associatie met een \texttt{UnitType}. Dit model werkt echter niet, omdat een \texttt{Ambulance} wel extra informatie bevat. Het dient immers een ziekenhuis te kunnen selecteren. Optionele attributen zijn hierbij uit den boze omdat ze de \textit{Cohesion} verlagen. Bovendien druisen ze in tegen normalisatieprincipes uit bijvoorbeeld databanken. De derde onderzochte vorm was een hybride tussen de twee vorige. Hierbij werken we met polymorfisme, maar bevat \texttt{Unit} ook een typeattribuut. Dit model gaat echter in tegen heel wat principes: er ontstaat redundantie, \textit{Protected Variation} wordt geschonden, de \textit{Cohesion} daalt en er ontstaat meer \textit{Coupling}. We opteerden bijgevolg voor de eerste mogelijkheid.
\paragraph{EmergencyDescription}
Een ander probleem is hoe we informatie over deze velden naar buiten kunnen brengen. Hiervoor construeerden we een \verb+EmergencyDescription+ klasse. Deze klasse bevat informatie over de verschillende parameters: hun type, naam en eventueel een beschrijving. Bovendien is deze beschrijving in staat om te controleren of een bepaalde lijst van objecten aan deze beschrijving voldoet.