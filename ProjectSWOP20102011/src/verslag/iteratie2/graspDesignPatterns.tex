\subsection{GRASP patterns}
\subsection{Design patterns}
\subsubsection{Composite}
\paragraph{}
We stellen onze constraints op onze emergency voor als een boom. Deze implementatie is een toepassing van het \textit{Composite}-pattern. Hierbij zien we \texttt{Dispatch\-Units\-Constraint} in de rol van \texttt{Component} en de \texttt{Number\-Dispatch\-Units\-Constraint} is \'e\'en van de eventueel later uitgebreide \texttt{Leaf}s. Tot slot zien we \texttt{And\-Dispatch\-Units\-Constraint} als de \texttt{Composite} klasse. Gegeven de specificaties in de opgave is dergelijke structuur misschien ``overkill''. We zijn echter makkelijk in staat om nieuwe types constraints toe te voegen, net als connectoren (zoals bijvoorbeeld een OR). Het uitgewerkte UML diagram met de relevante methodes staat op figuur \ref{fig:compositePattern}.
\begin{figure}[htb]
\includegraphics[width=1.0\textwidth]{CD_compositePattern.pdf}
\caption{UML diagram van de implementatie van het \textit{Composite}-pattern in het project.}
\label{fig:compositePattern}
\end{figure}
Tot slot kan opgemerkt worden dat in het boek er operaties in de Composite-participant gedefinieerd worden. In deze implementatie voegen we eenvoudigweg geen operaties toe. Het kennen van de parent levert voor \verb+AndDispatchUnitsConstraint+ geen meerwaarde op. Verder kan geargumenteerd worden dat de opbouw van de boom hiermee vastligt: bottom-up, er kan dus bijgevolg geen boom met een tak naar zichzelf bestaan. Tot slot zou het ook kunnen betekenen dat een component op veschillende plaatsen in de boom voorkomt, wat de structuur dus meer dynamiek geeft.
\subsubsection{State}
Hoewel we geen \verb+cancel+-emergency use-case moesten implementeren, anticipeerden we toch op de creatie van nieuwe staten waarin een emergency zich kan bevinden. We modelleerden dan ook een toestandsdiagram zoals op figuur \ref{fig:stateDiagramEmergency}.
\begin{figure}[htb]
\centering
\begin{tikzpicture}
\node[rectangle,draw=black] (RBU) at (0,0) {Recorded but unhandled};
\node[rectangle,draw=black] (RIP) at (6,0) {Response in progress};
\node[rectangle,dashed,draw=black] (Cl) at (6,-3.2) {Cancelled};
\node[rectangle,draw=black] (C) at (12,0) {Completed};
\draw[->] (RBU) to node[above,midway]{\small\texttt{assignUnits}} (RIP);
\draw[->] (RIP.east) -| ++(0.5,1) -- ++(-1.0) -| (RIP.north);
\draw[->] (RIP) to node[above,midway]{\small\texttt{finishUnit}} (C);
\draw[dashed,->] (BRU) -- ++(0,-3.2) to node[above,midway]{\small\texttt{cancelEmergency}} (Cl);
\draw[dashed,->] (RIP) to node[above,midway,sloped]{\small\texttt{cancelEmergency}} (Cl);
\end{tikzpicture}
\caption{Beschrijving van de toestanden en overgangen van Emergency}
\label{fig:stateDiagramEmergency}
\end{figure}
Anderzijds willen we de voordelen die een \verb+enum+ ons biedt niet verliezen\footnote{Zoals bijvoorbeeld een opsomming van de verschillende toestanden.}. Daarom opteerden we voor een hybride structuur. Deze structuur behoudt in zekere zin de geest van het \textit{State}-pattern beschreven in het boek \cite{book:designpatterns}. In \verb#C++# zijn \verb+enum+s echter niet polymorf: het is een lijst van sleutels die met een binaire waarde geassocieerd worden. In java kunnen elementen in een enumeratie in zekere zin als een singleton-subklasse van de enumeratie beschouwd worden\footnote{Uiteraard gaat die vergelijking niet volledig op.}. Het gevolg is dat we ook methodes aan deze elementen kunnen toewijzen en dus individueel anders kunnen implementeren.
\begin{figure}[htb]
\includegraphics[width=1.0\textwidth]{CD_statePattern.pdf}
\caption{UML diagram van de implementatie van het \textit{State}-pattern in het project.}
\label{fig:statePattern}
\end{figure}
Het grote nadeel van deze methode is dat alle toestanden zichtbaar zijn. Indien we dus later in het project juist een toestand willen implementeren waarover we niet kunnen filteren zal deze implementatie grondig bekeken moeten worden. Verder biedt deze implementatie alle voordelen van het \textit{State}-pattern en een \verb+enum+.
\subsubsection{Factory Method}
Omdat units en emergencies vaak aangemaakt worden met behulp van een tekstbestand of door een extern systeem met behulp van een \verb+String+, leek het ons nuttig om hiervoor een \textit{Factory Method}-pattern te gebruiken. Op die manier kunnen we dan een set van factories bijhouden, waarbij iedere factorie een bepaald derectief bijhoudt. Indien bij het inlezen van het tekstbestand een derectief wordt ingelezen, zal de bijbehorende factorie uit de set gehaald worden, die dan vervolgens een unit of emergency aanmaakt. Hierbij werden we echter geconfronteerd met een belangrijk probleem: de parameters van de verschillende units of emergencies zijn niet uniform. We kunnen dus bijgevolg geen abstracte factory laag bouwen waarbij de parameters gesepcifieerd zijn. Dit losten we echter op door een lijst van objecten als parameter mee te geven. Parameters die wel bekend waren\footnote{Omdat ze in de constructor van bijvoorbeeld \verb+Emergency+ reeds gedefinieerd zijn.} werden uiteraard wel in de methode signatuur opgenomen. Dit probleem werd op verschillende constructie patterns bestudeerd maar werd nergens concreet opgelost\footnote{Een prototype kan dit misschien wel oplossen, maar ons domein zou hierop fout kunnen reageren, vanwege finale velden. Bovendien gaan sommige methodes uit van deze finale velden}. De implementatie is beschreven op figuur \ref{fig:factoryMethodPattern}.
\begin{figure}[thtb]
\includegraphics[width=1.0\textwidth]{CD_factoryMethodPattern.pdf}
\caption{UML diagram van de implementatie van het \textit{Factory Method}-pattern in het project.}
\label{fig:factoryMethodPattern}
\end{figure}
Een ander probleem is hoe we informatie over deze velden naar buiten kunnen brengen. Hiervoor construeerden we een \verb+EmergencyDescription+ klasse. Deze klasse bevat informatie over de verschillende parameters: hun type, naam en eventueel een beschrijving. Bovendien is deze beschrijving in staat om te controleren of een bepaalde lijst van objecten aan deze beschrijving voldoet.
\subsubsection{Strategy}
Om units terug te trekken van een emergency hebben we het \textit{strategy}-pattern toegepast. In de opgave zijn er twee mogelijke manieren.
Ofwel mag een unit zich terugtrekken, mits hij aan bepaalde voorwaarden voldoet. Ofwel mag deze zich nooit terugtrekken.
Het voordeel van het \textit{Strategy}-pattern is dat we eenvoudig nieuwe manieren van terugtrekken kunnen toevoegen door een nieuwe subklasse van \texttt{WithdrawBehavior} toe te voegen.
Ook als er nieuwe soorten units toegevoegd worden, hoeven we niet steeds de hele withdraw-methode te kopi\"eren.
\begin{figure}[thtb]
\includegraphics[width=1.0\textwidth]{WithdrawStrategyPattern.pdf}
\caption{UML diagram van de implementatie van het \textit{Strategy}-pattern bij het terugtrekken van units.}
\label{fig:withdrawStrategyPattern}
\end{figure}